> 🌹作者:云小逸 
> 📝个人主页:[云小逸的主页](https://blog.csdn.net/m0_68865259?spm=1019.2139.3001.5343)
> 📝码云：[云小逸 (YunXiaoYi003) - Gitee.com](https://gitee.com/YunXiaoYi003)
> 🤟motto:要敢于一个人默默的面对自己，**==强大自己才是核心==**。不要等到什么都没有了，才下定决心去做。种一颗树，最好的时间是十年前，其次就是现在！学会自己和解，与过去和解，努力爱自己。==希望春天来之前，我们一起面朝大海，春暖花开！==🤟
> 👏专栏：C++👏👏专栏：刷题👏
> 👏专栏：C语言初阶👏👏专栏：数据结构👏


@[TOC](文章目录)

---
# 前言
C++是在C的基础之上，容纳进去了==面向对象编程思想==，并增加了许多==有用的库==，以及编程范式
等。熟悉C语言之后，对C++学习有一定的帮助，本章节主要目标：
1. 补充C语言语法的不足，以及C++是如何对C语言设计不合理的地方进行优化的，比如：作用域方面、IO方面、函数方面、指针方面、宏方面等。
2. 为后续类和对象学习打基础。


这篇文章开始，我们将进入==C++的正式学习==，加油！一起进步！


—————————————————————————————————————
首先先写上几句话：献给==坚持创作==的我和点开这篇文章希望==进步==的你

> 1.孤独是什么?是洗了个头发，梳了个漂亮的发型，换了双干净的鞋子，穿了件帅气的衣服。然后，去楼下超市买了一瓶可乐就回来了。
>
> ----热评来自《风居住的街道》
>
>
> <table><tr><td
> bgcolor=Beige>2.可能生活，有太多无能为力和无可奈何，可总归还是要努力一点，开心一点，想开的一点，毕竟，历经山河，人间值得，加油吧!
> ----热评来自《理想三旬》</td></tr></table>
>
> <table><tr><td
> bgcolor=MistyRose>3.这个世界除了朝九晚五，还有很多人要加班到深夜。没有双休，没有热好的粥，没有灯火通明的家。用尽全力去生活，不过勉强温饱。要相信生活不会总是一片黑暗，你想要的终会到来。
> ----热评来自《万家灯火》</td></tr></table>
> 
>
> 
>
>
> 4.你好像瘦了，头发也变长了，背影陌生到让我觉得，见你是上个世纪的事，然后你开口叫我名字，我就想笑，好像自己刚刚放学，只在楼门口等了你五分钟而已
>
> ----热评来自《十年》

# 1 . C++关键字(C++98)
![在这里插入图片描述](https://img-blog.csdnimg.cn/050549a6937c4cbe97be7443ed889460.jpeg#pic_center)
C++总计63个关键字，C语言32个关键字
ps：下面我们只是看一下C++有多少关键字，不对关键字进行具体的讲解。后面我们学到以后再细讲。
# 2.命名空间
## a.原因：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2c4b4342c05d4a89bb5d66eefe6bb012.jpeg#pic_center)
出现错误的原因是：
在C语言中头文件中#include<stdlib.h>中含有==rand函数==，故，当你在定义一个变量为rand的时候，编译器就会报错，因此可以开辟一个==命名空间==进行调用rand。
// C语言没办法解决类似这样的**命名冲突问题**，所以C++提出了**namespace**来解决
![在这里插入图片描述](https://img-blog.csdnimg.cn/9a0b0547912a4c3f8f9338521352914e.jpeg#pic_center)
而且一般在做一个项目的时候，基本上是多人协作，使用命名空间，可以有效避免**由于两人命名变量相同而导致的语法错误。**
## b.优点：
1.对标识符的名称进行**本地**化，以避免命名冲突或名字污染
2.避免项目组之间的**代码冲突**
3.避免了**命名冲突问题**
## c.域作用限定符( :: )
访问命名空间的符号，如==bit::rand==
 ::a;域作用限定符前面是空格，表示访问文件的==全局变量==

## d.命名空间的定义：
定义命名空间，需要使用到**namespace关键字**，后面跟**命名空间的名字**，然后接一对{}即可，{}中即为命名空间的成员。
// bit是命名空间的名字，**一般开发中是用项目名字做命名空间名**。
// 我们上课用的是bit，大家下去以后自己练习用自己名字缩写即可，如张三：zs
### （1） 正常的命名空间定义
**// 命名空间中可以定义变量/函数/类型**

```cpp
printf("%d",rand);
printf("%d",bit::rand);
```
当输出的时候，如果没有使用域作用限定符时，默认查找规则是：==先在局部找，找不到再在全局中找。==
使用了域作用限定符，不会影响变量的生命周期，，只是==限定域和编译时的查找规则。==
没有指定（使用::）就使用默认查找规则，指定了找不到，就会**报错**。

> 命名空间中的变量是**全局变量**，放在**静态区**。
> 只有函数中的变量才是局部变量。
> 预处理的时候，头文件会展开，放在全局中。

```cpp
struct bit::Node * cur =NULL;
```


### （2）命名空间可以嵌套

```cpp
// test.cpp
namespace N1
{
    int a;
    int b;
    int Add(int left, int right)
    {
        return left + right;
    }
    namespace N2//嵌套
    {
        int c;
        int d;
        int Sub(int left, int right)
        {
            return left - right;
        }
    }
}

```

主函数调用：

```cpp
N2::N1::c=2;
```

### （3）自动合并
同一个工程中允许存在**多个相同名称**的命名空间,编译器最后会合成同一个命名空间中。
// ps：一个工程中的test.h和上面test.cpp中两个N1会被合并成一个
//**只有同一级的才会自动合并**

注意：
命名空间嵌套的时候，若两个命名空间名字相同，不会进行自动合并（这种情况几乎没有，编代码基本不会这样编，就比如爸爸和儿子的名字正常情况下名字不相同，这里说明是为了防止一些读者钻牛角尖）

## 注意：
**// ==std，C++官方库内容定义的命名空间==**
一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。
## e.命名空间的使用
命名空间的使用有**三种方式**：
### （1）加命名空间名称及作用域限定符

```cpp
int main()
{
    printf("%d\n", N::a);
    return 0;    
}
```
### （2）使用using将命名空间中某个成员引入

```cpp
using N::b;
int main()
{
    printf("%d\n", N::a);
    printf("%d\n", b);
    return 0;    
}
```
### （3）使用using namespace 命名空间名称引入

```cpp
using namespce N;
int main()
{
    printf("%d\n", N::a);
    printf("%d\n", b);
    Add(10, 20);
    return 0;    
}
```
# 3.C++的输入输出
新生婴儿会以自己独特的方式向这个崭新的世界打招呼，C++刚出来后，也算是一个新事物，新生婴儿会以自己独特的方式向这个崭新的世界打招呼，C++刚出来后，也算是一个新事物。
那C++是否也应该向这个美好的世界来声问候呢？我们来看下C++是如何来实现**问候**的。

## （1）Hello world
//Hello world   根据刚才**命名空间的三种使用方法**，我们可以用==三种方法输出Hello world==
### a.全部展开：

```cpp
//方法1：全部展开

#include<iostream>

// std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中
using namespace std;
// 用起来就方便了，命名空间的隔离墙拆了
// 日常练习，算法，小程序，这么用可以，项目最好不要这么用

int main()
{
	cout << "Hello world!" << endl;
	return 0;
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/9c9c8f740f504fd690ed559a94d70735.jpeg#pic_center)

### b.部分展开（指定展开）

```cpp
//方法2：部分展开（指定展开） -- 常用展开，自己定义的时候避免跟常用重名即可

#include<iostream>
 
using std::cout;//指定展开

int main()
{
	cout << "Hello world!" << std::endl;
	return 0;
}


```
![在这里插入图片描述](https://img-blog.csdnimg.cn/5206389252af47a1ba8deaef417689da.jpeg#pic_center)
### c.不展开：

```cpp
//方法3:不展开
#include<iostream>//不展开

int main()
{
	std::cout << "Hello world!" << std::endl;
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/0da87dbce0ff4e0288c77e5cf4eb5bae.jpeg#pic_center)
## （2）std命名空间的使用惯例：
**std是C++标准库的命名空间**，如何展开std使用更合理呢？
1. 在日常练习中，建议直接==using namespace std==即可，这样就很方便。
2. using namespace std展开，标准库就全部暴露出来了，**如果我们定义跟库重名的类型/对象/函数，就存在冲突问题**。该问题在日常练习中很少出现，但是项目开发中代码较多、规模大，就很容易出现。所以建议在项目开发中使用，像std::cout这样使用时指定命名空间 +using std::cout展开常用的库对象/类型等方式。
## （3）cout,<<,>>,cin,endl
### a.cout-----输出-----C语言中的==printf==
**c----console,控制台
具有==自动识别变量类型==的功能（不会影响程序运行效率）
cout-----全局对象，函数重载，封装**
> cout 用于在计算机屏幕上显示信息，**是C++中< iostream> 类型的对象**，C++的输出是用“流”(stream)的方式实现的，流运算符的定义等信息是存放在C++的输入输出流库中的，因此如果在程序中使用cout和流运算符，就必须使用**预处理命令**把头文件stream包含到本文件中，即
> < iostream > 库，该库定义的名字都在命名空间 std 中，所以 cout 全称是 **std::cout**
### b.<<,>>-----流插入，流提取
<<是**流插入**运算符，>>是**流提**取运算符
### c.cin-------输入-------C语言中的==scanf==
> C++编程语言I/O流中的标准输入流，需要包含iostream头文件,即#include <iostream>,cin 分为两个音节 读为 "c in"，音标 "/si:ɪn/"。
> cin代表标准输入设备，使用右移运算符 ">>" 从设备键盘取得数据，送到输入流对象cin中，然后送到内存。使用cin可以获得多个从键盘的**输入值**，其具体使用格式如下：
> cin >> 表达式1 >>表达式2...>> 表达式n；
### d.endl-----换行-----C语言中的'\n'
## （4）注意：
1.实际上cout和cin分别是iostream和istream类型的对象，>>和<<也涉及**运算符重载**等知识，
2.在一些情况下，C语言的输入输出比C++方便，如
要输出格式为==小数点后几位==的时候，**用C语言**
输出格式为==字符串和值交替==的时候，**用C语言**
3.早期标准库将所有功能在全局域中实现，声明在**.h后缀的头文件**中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，**规定C++头文件不带.h**；旧编译器(vc 6.0)中还支持<iostream.h>格式，后续编译器已不支持，因此推荐使用< iostream >+std的方式。
# 4.缺省参数
## （1）缺省参数的概念：
缺省参数是声明或定义函数时为函数的参数==指定一个缺省值==。**在调用该函数时，如果没有指定实参则采用该形参的缺省值，否则使用指定的实参。**

```cpp
void Func(int a)//正常的函数是这个样子
void Func(int a = 0)//缺省参数就是为函数的参数指定一个参数
```

例子：
 // 函数没有实参时，使用==参数的默认值（缺省值）==
 // 函数有实参时，使用指定的实参
```cpp
void Func(int a = 0)
{
 cout<<a<<endl;
}
int main()
{
 Func();     // 函数没有传参时，使用参数的默认值（缺省值）
 Func(10);   // 函数有传参时，使用指定的实参
return 0;
}
```
## （2）缺省参数分类
### a.全缺省参数
**即函数形参全部指定一个缺省值**

```cpp
void Func(int a = 10, int b = 20, int c = 30)
 {
     cout<<"a = "<<a<<endl;
     cout<<"b = "<<b<<endl;
     cout<<"c = "<<c<<endl;
 }
```
### b.半缺省参数（部分缺省参数）
**即函数形参不全部指定缺省值，0<指定缺省值的个数<全缺省参数**

```cpp
void Func(int a, int b = 10, int c = 20)
 {
     cout<<"a = "<<a<<endl;
     cout<<"b = "<<b<<endl;
     cout<<"c = "<<c<<endl;
 }
```
#### 注意：
**1. 半缺省参数必须从右往左依次来给出，==不能间隔着给==，依次传递
2. 缺省参数不能在函数声明和定义中同时出现
3. 缺省值必须是常量或者全局变量（很少）
4. C语言不支持（编译器不支持）**

```cpp
//a.h
  void Func(int a = 10);
  
  // a.cpp
  void Func(int a = 20)
 {}
  
  // 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，
  //那编译器就无法确定到底该用那个缺省值。
```

**因为若在函数声明和定义中的指定缺省值不相同的话，程序将会出现BUG，产生冲突。
故，一般在函数的声明（<____.h>文件中）中使用缺省参数，函数的定义中不使用。**


# 5.函数重载
重载不要看这个名字，感觉很高深。
实际上，通俗上讲，重载就是一词多义
比如：以前有一个笑话，国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！”
## （1）函数重载的概念：
**函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明==几个功能类似的同名函数==，这些同名函数的形参列表(==参数个数 或 类型 或 类型顺序==)不同，常用来处理实现功能类似数据类型不同的问题。**
### a.参数类型不同

```cpp
#include<iostream>

using namespace std;

// 1、参数类型不同
int Add(int left, int right)
{
	cout << "int Add(int left, int right)" << endl;
	return left + right;
}
double Add(double left, double right)
{
	cout << "double Add(double left, double right)" << endl;
	return left + right;
}

int main()
{
	Add(10, 20);
	Add(10.1, 20.2);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/293948555ace45d7b310f8ed4c952e6a.jpeg#pic_center)
### b.参数个数不同

```cpp
#include<iostream>

using namespace std;

// 2、参数个数不同
void f()
{
	cout << "f()" << endl;
}
void f(int a)
{
	cout << "f(int a)" << endl;
}

int main()
{
	/*Add(10, 20);
	Add(10.1, 20.2);*/
	f();
	f(10);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/cd4e354ba86448189d29968dfc66383e.jpeg#pic_center)
### c.参数顺序不同：

```cpp
#include<iostream>

using namespace std;

// 3、参数类型顺序不同
void f(int a, char b)
{
	cout << "f(int a,char b)" << endl;
}
void f(char b, int a)
{
	cout << "f(char b, int a)" << endl;
}

int main()
{
	f(10, 'a');
	f('a', 10);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/a917163c679c4f7c84a43e4581b0c3cd.jpeg#pic_center)
**形参类型顺序不同，本质上还是==参数类型不同==。**
## （2）函数重载的原理：
**为什么C++支持函数重载，而C语言不支持函数重载呢？**
C语言不支持的原因：**同一个域，不可以出现相同名字的两个变量**
C++支持的原因：
我们先一步一步理解:**函数的调用的本质是call（调用）函数的地址**，
如：
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2451d034b654066aa09093641491ef8.jpeg#pic_center)
**然后我们要知道在编译过程中，符号表中放的是函数名和函数的地址。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/4b4b45bdb3944e15987233c328d6ca0c.jpeg#pic_center)

**C语言的符号表，一个函数名对应一个函数地址。
C++的符号表，一个函数名对应一个函数地址，==若存在重载，函数名就会填加一些修饰后缀，以便于区分。==
 由于Windows下vs的修饰规则过于复杂，而Linux下g++的修饰规则简单易懂，下面我们使用了g++演示了这个修饰后的名字。（==函数名修饰规则==）**
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/d1bedd422d0e466b9447748108481a01.jpeg#pic_center)
**采用C++编译器：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2446e575b6954a6fb3a9ac34fdd0ec52.jpeg#pic_center)
**通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是==通过函数修饰规则==来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。**

## （3）知识要点：
### 1.要点一：
```cpp
void func(int a, int b);
void func(int b, int a);
```
**上面这两个式子，这==不是==函数重载，就是同一个函数。**
### 2.要点二：
**返回值不同，不会构成函数重载。
原因：（不是函数修饰规则）真正的原因：调用时的==二义性==，编译器无法区分。**

# 最后
 **十分感谢你可以耐着性子把它读完和我可以坚持写到这里，送几句话，对你，也对我：**

> 1、小时候跟着父亲去城里卖西瓜，害怕同学会看到我，就拼命地将自己==隐藏起来==，一路心惊肉跳。
> 现在想来，那条路绿树成荫，阳光飒爽，
> <font color="#006600">若不是我害怕面对自己的不完美，一定能看到许多美好的景致，</font><br />**那条路，正如其他的所有路，从来都不应该被逃避**。
> ----热评来自《平凡之路》
> 2.、家人围着6岁的儿子问他的理想，儿子说他想当医生。外婆说医生好，社会地位高，奶奶说待遇也不错，爷爷说除了工资还有其他收入呢!外公说更重要的是以后找对象方便。爸爸听后满意的问儿子为什么想当医生。他说：“<font color="#006600">不是说医生可以治病救人吗?</font><br />”
> ----热评来自《理想》
> 3.、一个男人最难熬的状态就是：<table><tr><td bgcolor=MistyRose>眼里操心着父母，脑子里想着事业，心里装着个姑娘，胸腔中盛着远方，可是最后失望于父母，辜负了姑娘，看不见远方。</td></tr></table>   ----热评来自《蓝莲花》

**最后如果觉得我写的还不错，请不要忘记==点赞==✌，==收藏==✌，加==关注==✌哦(｡･ω･｡)**

**愿我们一起加油，奔向更美好的未来，愿我们从懵懵懂懂的一枚==菜鸟==逐渐成为==大佬==。加油，为自己点赞！**



---